#undef __ARM_FP
#include "mbed.h"
#include <stdio.h>
#include <string.h>

// Maximum number of element the application buffer can contain
#define MAXIMUM_BUFFER_SIZE 256
#define UART1_TX PB_6
#define UART1_RX PB_7
#define UART2_TX PA_2
#define UART2_RX PA_3
#define UART3_TX PC_10
#define UART3_RX PC_11

// Create a DigitalOutput object to toggle an LED
//PB_14-> send data, PB_15-> receive data
static DigitalOut led_PB14(PB_14);
static DigitalOut led_PB15(PB_15);

// Create a BufferedSerial object with a default baud rate.
static BufferedSerial serial_port(UART3_TX, UART3_RX);
//static BufferedSerial serial_port(UART2_TX, UART2_RX);

// Application buffer to send the data
char bufRx[MAXIMUM_BUFFER_SIZE] = {0};
char bufTx[MAXIMUM_BUFFER_SIZE] = {0};
char bufCommand[MAXIMUM_BUFFER_SIZE] = {0};
char Msg_Connection_Closed[] = "Wrong Command!\r\nConnection is Closed!\r\n";
char Msg_WrongCommand[] = "Wrong Command!\r\nPlease key in again!\r\n";
uint32_t num1 = 0, num2 = 0, num3 = 0, num4 = 0;
char commandReceived = 0;
bool commandFound = false;
bool connectionClosed = false;
void UpdateClient(char chCommand)
{
snprintf (bufTx, sizeof(bufTx), "Command: %c is done!\r\n", chCommand);
num1 = serial_port.write(bufTx, strlen(bufTx));
if (num1)
{
// Toggle the LED.
led_PB14 = !led_PB14;
//printf ("Send %d characters to client.\n", num1);
}
thread_sleep_for(500);
}
void Error_Msg(char * pMsg)
{
strcpy(bufTx, pMsg);
num1 = serial_port.write(bufTx, strlen(bufTx));
if (num1)
{
// Toggle the LED.
led_PB14 = !led_PB14;
//printf ("Send %d characters to client.\n", num1);
}
thread_sleep_for(500);
}
int main(void)
{
// Set desired properties (8-N-1).
serial_port.set_baud(9600);
//serial_port.set_baud(115200);
//serial_port.set_baud(19200);
//serial_port.set_baud(38400);
//serial_port.set_baud(57600);
//serial_port.set_baud(74880);
serial_port.set_format(
/* bits */ 8,
/* parity */ BufferedSerial::None,
/* stop bit */ 1
);
serial_port.set_flow_control(mbed::BufferedSerial::Disabled);
while (1)
{
memset(bufRx, 0, sizeof(bufRx));
num2 = serial_port.read(bufRx, sizeof(bufRx));
if (num2)
{
printf("Command length: %d\n", num2);
// Toggle the LED.
led_PB15 = !led_PB15;
bufRx[num2] = '\0';
printf("Command: %s\n", bufRx);
commandReceived = bufRx[0];
switch (commandReceived)
{
case '0':
break;
case '1':
UpdateClient(commandReceived);
break;
case '2':
break;
case '3':
UpdateClient(commandReceived);
break;
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
//wrong command
Error_Msg(Msg_WrongCommand);
break;
default:
//CLOSE CONNECTION ??
connectionClosed = true;
Error_Msg(Msg_Connection_Closed);
break;
}
}
if (connectionClosed)
break;
thread_sleep_for(500);
}
while (1); //stop here
}
